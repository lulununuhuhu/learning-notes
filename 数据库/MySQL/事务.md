# 事务

## 概念

> 事务是包含一系列操作的逻辑单元，使数据库从一个状态变化到另一个状态。
>
> 在数据库中，事务作为一个操作单元，拥有不可分割的特性，展开来说就是这个事务的所做的操作要么都被提交(**commit**),要么就放弃所有的修改，整个事务回滚(**rollback**)到最初状态。

## 事务的ACID特性

* 原子性(atomicity)

  事务是一个不可分割的工作单位，要么全部提交，要么全部回滚。

* 一致性 (consistency)

  事务执行的前后，保证是从一个**合法状态**转移到另一个**合法状态**，合法状态是语义上的不是语法上的，和具体的业务有关。合法状态可以是指满足创建库时的具体约束以及满足业务的定义的状态。

  不合法的状态可以是：（以银行转账为例）

  * A账户有200元，转账300元，那账户有-100元，这是不合法状态
  * A账户转给B账户50元，A账户减50，然而B没有加50元，这是不合法状态

  一旦出现不合法的状态，那就是破坏了事务的一致性。

* 隔离性(isolation)

  一个事务的执行不能被并发的其他事务的执行所影响，即要保证一个事务在操作内部数据时并发执行的事务不能相互干扰。类似于多线程中同步代码块的感觉，一个事务就是一个同步代码块，它在执行时是上了🔒的。

* 持久性(durability)

  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是**永久性**的，接下来的其他操作和数据库故障不应对这个改变结果有任何影响。

  持久性是通过**事务日志**来保证的。事务日志包括**重做日志**和**回滚日志**。当我们通过事务对数据库的数据进行修改时，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样的话，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而达到持久性。

## 使用事务的方式

### 显式事务

```sql
# 开启一个新的事务(两种方式)
start transaction;
begin;
/*
事务内容
*/

IF exception :Then ROLLBACK;
commit;
```

通过关键字显式的声明事务的具体操作（一系列具体的sql语句）。

在一个事务中有多个sql语句操作，并且不想因为执行事务后半段sql操作出现某些异常导致回滚到事务前，导致前面的sql操作无效的情况，那可以在事务内部的sql操作中指明savepoint，出现异常时，事务会roll back到上一个savepoint处的状态。

###  隐式事务

```sql
show variables like 'autocommit';# 查看当前关键字autocommit的值
```

```sql
set autocommit = true; # 设置自动提交
```

隐式事务的情况有：

1. DDL语句，对于一些数据库对象如视图、索引、数据库、存储过程、函数等的创建都是默认隐式提交，不管是否设置了autocommit为true。
2. 设置了set autocommit = true的情况，则每个sql语句都可以看成一个独立的事务

## 事务隔离级别

MySQL是一个客户端/服务器架构的软件。一个服务器通常需要处理多个客户端上的请求，这些请求包含在事务中，即需要并发的处理多个事务。在保证事务的隔离性的情况下，同时保证多个事务访问同一数据的请求处理的性能尽量不下降。

首先可以来考虑一下多个事务并发运行的情况下处理同一数据时会出现的数据并发问题：

1. 脏读（Dirty Read）

   可以简单的概括为读了无效的数据。两个事务SessionA和SessionB，SessionA事务读取了SessionB**修改了但未提交**的数据，最后SessionB事务回滚后，导致SessionA事务读取的数据无效。

2. 脏写(Dirty Write)

   可以简单的概括为写了数据并提交之后但最终并没有生效。两个事务SessionA和SessionB，SessionA事务修改了数据并提交了，但SessionB在SessionA之前也对这个数据进行了修改但它最后回滚了，导致SessionA修改的操作也未能生效。

3. 不可重复读(Non-Repeatable Read)

   可以简单的概括为由于多个事务访问同一个数据，事务SessionB更新了多次数据，SessionA重复读数据导致每次读的结果都不同。

4. 幻读(Phantom)

   对于两个事务SessionA、SessionB，SessionA从一个表中读取了一个字段，然后SessionB在该表中插入了一些新的行。如果之后SessionA再次读取同一个表，就会比之前多出几行。

在这四种并发性问题中，按严重程度排序：脏写	>	脏读	>	不可重复读	>	幻读

针对这四种并发性问题，设置了四种隔离级别。

`READ UNCOMMITTED` :读未提交。在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。

`READ COMMITTED`:读已提交。在该隔离级别，一个事务只能看见已经提交事务所做的改变。这个大多数DBMS的默认隔离级别（MySQL不是，MySQL的默认隔离级别是REPEATABLE READ）。

`REPEATABLE READ`:可重复读。事务A读取了一条内容，事务B对该条内容进行了更新，事务A再读取该数据，读到的还是原来的内容。

`SERIALIZABLE`：可串行化。在事务A处理表的数据期间，禁止其他事务对该表进行操作。

> 这四种隔离级别的共同点是都解决了脏写这个问题。隔离级别越高，能解决的并发问题就更多，但代价就是并发性能越低。

| 隔离级别         | 解决脏读 | 解决不可重复读 | 解决幻读 | 是否加锁读 |
| ---------------- | -------- | -------------- | -------- | ---------- |
| READ UNCOMMITTED | ×        | ×              | ×        | ×          |
| READ COMMITTED   | √        | ×              | ×        | ×          |
| REPEATABLE READ  | √        | √              | ×        | ×          |
| SERIALIZABLE     | √        | √              | √        | ×          |

### 读未提交(READ UNCOMMITTED)

读未提交的举例：

![image-20220524203103454](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20220524203103454.png)

这个案例中，事务A想实现张三向李四账户转账100的操作，事务B想实现撤销张三向李四账户转账100的操作。但由于事务B读了未提交的内容，并且事务A最后回滚到最初状态了，所以事务B的操作不是撤销，而是变成了李四给张三转账100了。

### 读已提交（READ COMMITTED）

读已提交的示例：

![image-20220524211242709](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20220524211242709.png)

### 可重复读

可重复读的示例：

![image-20220524212504319](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20220524212504319.png)

