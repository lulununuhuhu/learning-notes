## 约束

### 约束(constraint)概述

> 约束时为了防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。
>
> 约束是表级的强制规定。

为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：

* 实体完整性(Entity Integrity):例如同一个表中，不能存在两条完全相同无法区分的记录
* 域完整性(Domain integrity):例如：年龄范围0~120 性别范围男/女
* 引用完整性(Referential Integrity):例如：员工所在部门，在部门表中要能找到这个部门
* 用户自定义完整性(User_defined Integrity):例如：用户名不唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍

约束可以在创建表时规定约束（通过CREATE TABLE语句），或者在表创建之后通过ALTER TABLE语句规定约束。

### 约束的分类

根据约束数据列的限制，可以分为：

* 单列约束：每个约束只约束一列
* 多列约束：每个约束可约束多列数据

根据约束的作用范围，可以分为：

* 列级约束：只能作用在一个列上，跟在列的定义后面

  ```sql
  #定义格式
  CREATE TABLE 表名称(
  	字段名 数据类型,
      字段名 数据类型 约束类型,
      字段名 数据类型 约束类型
  );
  ```

* 表级约束：可以作用在多个列上，不与列一起，而是单独定义

  ```sql
  #定义格式
  CREATE TABLE 表名称(
  	字段名 数据类型,
      字段名 数据类型,
      字段名 数据类型,
      [CONSTRAINT 约束名] 约束类型(字段名),
      [CONSTRAINT 约束名] 约束类型(字段名)
  );
  ```

```
		 位置            支持的约束类型              是否可以起约束名 
列级约束： 列的后面       语法都支持，但外键没有效果       不可以 
表级约束： 所有列的下面    默认和非空不支持，其他支持       可以（主键没有效果）
```

根据约束所起的作用，可以分为：

* **NOT NULL** **非空约束，规定某个字段不能为空**

* **UNIQUE** **唯一约束**，**规定某个字段在整个表中是唯一的**

* **PRIMARY KEY 主键(非空且唯一)约束**

* **FOREIGN KEY** **外键约束**

* **CHECK** **检查约束**

* **DEFAULT** **默认值约束**

### 非空约束

关键字:NOT NULL,只能作为表级约束，限定某个列字段非空

```sql
CREATE TABLE 表名称(
	字段名 数据类型,
    字段名 数据类型 NOT NULL,
    字段名 数据类型 NOT NULL
);
```

例：

```sql
CREATE TABLE IF NOT EXISTS test1(
	id INT NOT NULL,
	last_name VARCHAR(15) NOT NULL,
	email VARCHAR(25),
	salary DECIMAL(10,2)
);
#创建test1表，其中last_name和id为NOT NULL约束

# 在ALTER TABLE时添加约束
ALTER TABLE test1
MODIFY email VARCHAR(25) NOT NULL;
```

### 唯一性约束

1. 关键字:UNIQUE 用来限制某个字段/某列的值不能重复。唯一性约束中允许出现多个空值:NULL

2. 特点:
   * 同一个表可以有多个唯一约束;
   
   * 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一;
   
   * 唯一性约束允许列值为空;

   * 在创建唯一约束的时候，如果不给唯一约束命名，默认情况下如果是组合列，那么默认和()
   
     中排在第一个的列名相同；如果是单列，则默认和字段名相同;
   
   * 和列名相同;
   
   * **MySQL会给唯一约束的列上默认创建一个唯一索引**
   
3. 声明方式

   ```sql
   # 列级约束写法
   create table 表名称
   ( 
       字段名 数据类型, 
       字段名 数据类型 unique,
       字段名 数据类型 unique [key]
   );
   
   CREATE TABLE IF NOT EXISTS test2(
   	id INT UNIQUE,
   	last_name VARCHAR(15),
   	email VARCHAR(25) UNIQUE,
   	salary DECIMAL(10,2)
   );
   
   # 表级约束写法
   create table 表名称
   ( 
       字段名 数据类型,
       字段名 数据类型,
       字段名 数据类型,
       [constraint 约束名] unique [key](字段名) 
   );
   
   CREATE TABLE IF NOT EXISTS test2(
   	id INT,
   	last_name VARCHAR(15),
   	email VARCHAR(25),
   	salary DECIMAL(10,2),
   	#表级约束
   	#[CONSTRAINT 约束名] 约束类型(字段名)
   	CONSTRAINT uk_id UNIQUE(id),
   	CONSTRAINT uk_email UNIQUE(email)
   );
   
   # 复合唯一约束，多个字段作为一个组合形成唯一
   create table 表名称(
   	字段名 数据类型,
       字段名 数据类型,
       字段名 数据类型,
       [constraint 约束名] unique (字段名1,字段名2,...)
   );
   CREATE TABLE IF NOT EXISTS `user`(
   	id INT,
   	`name` VARCHAR(15),
   	`password` VARCHAR(25),
   	
   	#表级约束
   	CONSTRAINT uk_user_name_pwd UNIQUE(`name`,`password`)
   );
   
   ```

4. 添加唯一性索引

      ```sql
      # 方式一
      ALTER TABLE 表名
      ADD CONSTRAINT 索引号 UNIQUE(字段名);
      
      # 方式二
      ALTER TABLE 表名
      MODIFY 字段名 数据类型 UNIQUE;
      ```
      
5. 删除唯一性约束

      ```sql
      每个唯一性约束在创建时都会有一个唯一性索引。默认情况下是字段名，也可以通过以constraint 约束名的方式进行自定义。在删除唯一性约束的时候，要找到该约束的索引。
      
      # 查询每个表的唯一性索引
      show index from 表名;
      
      # 删除唯一性约束
      alter table 表名
      drop index 索引名;
      ```


### 主键(primary key)约束

主键，用来唯一标识表中的一行记录。主键约束相当于**唯一约束+非空约束的组合**。主键约束列**不允许重复，也不允许出现空值**。

1. 主键特点

   * 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建；

   * 主键约束对应着表中的一列或者多列（复合主键），如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复；

   * MySQL的主键名总是**PRIMARY**，就算自己命名了主键约束名也没用；

   * 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的**主键索引**（能够根据主键查询

     的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了；

   * 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的

     值，就有可能会破坏数据的完整性

2. 声明主键约束

   ```sql
   #列级声明方式
   create table 表名称( 
       字段名 数据类型 PRIMARY KEY,
       字段名 数据类型, 
       字段名 数据类型
   );
   #表级声明方式
   create table 表名称( 
       字段名 数据类型, 
       字段名 数据类型, 
       字段名 数据类型, 
       [constraint 约束名] primary key(字段名)
   );
   
   #复合主键
   create table 表名称( 
       字段名 数据类型,
       字段名 数据类型,
       字段名 数据类型, 
       primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段 
   );
   ```

3. 添加主键约束

   ```sql
   ALTER TABLE 表名称 
   ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键
   ```

4. 删除主键约束

   ```sql
   alter table 表名称 
   drop primary key;
   ```


### 自增列：AUTO_INCREMENT

关键字：auto_increment，某个字段的值自增

1. 自增列特点

   * 一个表最多只能有一个自增长列
   * 当需要产生唯一标识符或顺序值时，可以设置自增长
   * 自增长列约束的列**必须是键列(主键列、唯一键列)**
   * 自增约束的列的数据类型**必须是整数类型**
   * 如果自增列指定了0和null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，则直接赋为具体值。（实际开发中，对于自增的主键列一般不去手动赋值）

2. 创建自增约束

   ```sql
   CREATE TABLE IF NOT EXISTS test2(
   	id INT PRIMARY KEY AUTO_INCREMENT,
   	`name` VARCHAR(15)
   );
   ```

3. 添加自增约束

   ```sql
   ALTER TABLE 表名
   MODIFY 字段名 字段类型 AUTO_INCREMENT;
   ```

4. 删除自增约束

   ```sql
   ALTER TABLE 表名
   MODIFY 字段名 字段类型;
   ```

### 外键约束

关键字：FOREIGN KEY，限制某个表的某个字段的引用完整性。例如员工表中的员工的部门号字段必须在部门表中能找到对应的部分。

1. 主表和从表/父表和子表

   主表(父表):被引用的表或者说被参考的表

   从表(子表):应用别人或者参考别人的表

   例如：员工表的部门号字段值需要参考部门表：则部门表是主表，员工表是从表；学生表，课程表，选课表中：选课表的学生和选课表的课程分别需要参考学生表和课程表，所以学生表和课程表是主表，选课表就是从表

2. 特点：

   * 因为从表引用的值必须唯一，所以从表的外键列**必须引用参考主表的主键或唯一约束的列**

   * 在创建外键约束时，如果不给外键约束命名，**默认名不是列名，而是自动产生一个外键名**（例如

     student_ibfk_1;），也可以指定外键约束名

   * 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表;删表时，先删从表（或先删除外键约束），再删除主表

   * 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖

     该记录的数据，然后才可以删除主表的数据(默认的约束等级情况下)

   * 在“从表”中指定外键约束，并且一个表可以建立多个外键约束

   * 删除外键约束后，必须 **手动 **删除对应的索引

3. 添加外键约束

   * 建表时：

     ```sql
     create table 主表名称( 
         字段1 数据类型 primary key, 
         字段2 数据类型 
     );
     create table 从表名称( 
         字段1 数据类型 primary key, 
         字段2 数据类型, 
         [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) );
         #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样
     -- FOREIGN KEY: 在表级指定子表中的列
     -- REFERENCES: 标示在父表中的列
     
     #案例
     CREATE TABLE dept1(
     	dept_id INT,
     	dept_name VARCHAR(15)
     );
     #给dept_id添加约束
     ALTER TABLE dept1
     ADD PRIMARY KEY (dept_id);
     
     #再创建从表
     CREATE TABLE emp1(
     	emp_id INT PRIMARY KEY AUTO_INCREMENT,
     	emp_name VARCHAR(15),
     	department_id INT,
     	# 表级约束
     	CONSTRAINT fk_emp1_dept_id FOREIGN KEY (department_id) REFERENCES dept1(dept_id)
     );
     ```

   * 建表后：一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。

     ```sql
     ALTER TABLE 从表名 
     ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx];
     
     #案例
     create table dept( 
         did int primary key, #部门编号 
         dname varchar(50) #部门名称 
     );
     create table emp( 
         eid int primary key, #员工编号 
         ename varchar(5), #员工姓名 
         deptid int #员工所在的部门 
     );
     
     #dept表作为主表，emp表作为从表;emp表中的deptid依赖于dept表中的did
     alter table emp add foreign key (deptid) references dept(did);
     ```

4. 约束等级

   * Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录

   * Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子

     表的外键列不能为not null

   * No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作

   * Restrict方式 ：同no action， 都是立即检查外键约束

   * Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置

     成一个默认的值，但Innodb不能识别

   默认情况下，采用restrict等级

   对于外键约束，最好是采用: `ON UPDATE CASCADE ON DELETE RESTRICT` 的方式

   ```sql
   # 案例
   create table dept( 
       did int primary key, #部门编号 
       dname varchar(50) #部门名称 
   );
   create table emp( 
       eid int primary key, #员工编号 
       ename varchar(5), #员工姓名 
       deptid int, #员工所在的部门
   	foreign key (deptid) references dept(did) on update cascade on delete set null #把修改操作设置为级联修改等级，把删除操作设置为set null等级 
   );
   ```

   

5. 删除外键约束

   ```sql
   (1)第一步先查看约束名和删除外键约束 
   SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个 表的约束名 
   ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; 
   
   （2）第二步查看索引名和删除索引。（注意，只能手动删除） 
   SHOW INDEX FROM 表名称; #查看某个表的索引名 
   ALTER TABLE 从表名 DROP INDEX 索引名;
   ```

   

> 注：在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。所以，MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。

>在阿里开发规范中：【 强制要求 】不得使用外键与级联，一切外键概念必须在**应用层解决**。
>
>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学
>
>生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单 
>
>机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响
>
>数据库的 插入速度 。 

### CHECK约束

关键字check，用于检查某个字段的值是否符合指定的要求，一般指的是值的范围。

其中MySQL5.7中不持支check约束，MySQL8.0支持check约束。

```sql
# 案例
CREATE TABLE test(
	ename varchar(5), 
    gender char check ('男' or '女')
);

CREATE TABLE temp( 
    INT AUTO_INCREMENT, 
    NAME VARCHAR(20), 
    age INT CHECK(age > 20), PRIMARY KEY(id) 
);

age tinyint check(age >20) 或 sex char(2) check(sex in(‘男’,’女’))

CHECK(height>=0 AND height<3
```

### DEFAULT约束

关键字DEFAULT，给某个字段/某列指定默认值，一旦设置默认值。在插入数据中，如果没有显式赋值，则使用默认值。

1. 添加DEFAULT约束

   * 建表时

     ```sql
     create table 表名称( 
         字段名 数据类型 primary key,
         字段名 数据类型 unique key not null, 
         字段名 数据类型 unique key, 
         字段名 数据类型 not null default 默认值 
     );
     #默认值一般不在默认列和主键列添加
     
     #案例
     create table employee( 
         eid int primary key, 
         ename varchar(20) not null, 
         gender char default '男',
         tel char(11) not null default '' #默认是空字符串 
     );
     ```

   * 建表后

     ```sql
     alter table 表名称 modify 字段名 数据类型 default 默认值;
     #如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 删除了 #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了
     
     alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
     
     # 案例
     create table employee( 
         eid int primary key, 
         ename varchar(20), 
         gender char, 
         tel char(11) not null 
     );
     
     alter table employee modify gender char default '男'; #给gender字段增加默认值约束
     alter table employee modify tel char(11) default ''; #给tel字段增加默认值约束
     ```

2. 删除DEFAULT约束

   ```sql
   alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 
   alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束
   ```

   
