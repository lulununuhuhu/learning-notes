## 子查询

> 子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL4.1开始引入。
>
> SQL中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。

### 单行子查询

> 常用的单行操作符有： =   ！=    >     >=    <     <=

1. Where中的子查询

```sql
#查询工资大于149号员工的工资的员工的信息
SELECT last_name,salary,employee_id
FROM employees
WHERE salary > ( #括号中的子查询返回的是149号员工的工资
								SELECT salary
								FROM employees
								WHERE employee_id = 149
								);
```

```sql
# 返回公司工资最少的员工的last_name，job_id和salary
SELECT last_name,job_id,salary
FROM employees
WHERE salary = (
								#找到最低工资大小
								SELECT MIN(salary)
								FROM employees
								);
```

2. HAVING中的子查询

```sql
# 查询最低工资大于50号部门最低工资的部门id和其最低工资
SELECT department_id,MIN(salary)
FROM employees
WHERE department_id IS NOT NULL
GROUP BY department_id
HAVING MIN(salary)> (
											SELECT MIN(salary)
											FROM employees
											WHERE department_id = 50
										);
```

3. CASE中的子查询

```sql
SELECT employee_id,last_name,CASE department_id
	WHEN(SELECT department_id FROM departments WHERE location_id = 1800)  THEN
		'Canada'
	ELSE
		'USA'
END 'location'
FROM employees;
```

### 多行子查询

> 多行子查询，也称为集合比较子查询。当内查询返回多行时，使用多行比较操作符。

| 操作符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| IN     | 等于列表中的**任意一个**                                     |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的**某一个值**比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的**所有值**比较   |
| SOME   | 实际上是ANY的别名，作用相同，一般常用ANY                     |

1. IN操作符：

```sql
# 查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id,manager_id,department_id
SELECT employee_id,manager_id,department_id
FROM employees
WHERE manager_id IN (
									SELECT manager_id
									FROM employees
									WHERE employee_id IN (174,141)
									)
AND department_id IN (
									SELECT department_id
									FROM employees
									WHERE employee_id IN(174,141)
									);
```

2. ANY操作符：

```sql
SELECT employee_id,last_name,job_id,salary
FROM employees
WHERE job_id <> 'IT_PROG'
AND salary < ANY(
								 SELECT salary
								 FROM employees
								 WHERE job_id = 'IT_PROG'
								);
```

3. ALL操作符：

```sql
#返回其他job_id中比job_id为'IT_PROG'部门所有员工的工资都低的员工的员工号、姓名、job_id以及salary
SELECT employee_id,last_name,job_id,salary
FROM employees
WHERE job_id <> 'IT_PROG'
AND salary < ALL(
								 SELECT salary
								 FROM employees
								 WHERE job_id = 'IT_PROG'
								);
```

```sql
# 查询平均工资最低的部门id
# 一般容易想到用MIN(AVG(salary))来完成平均工资的最小值，但是MySQL中不支持聚合函数的嵌套使用
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) = (
									SELECT MIN(avg_sal)
									FROM(
											SELECT AVG(salary) avg_sal
											FROM employees
											GROUP BY department_id
									) new_table
);
```

### 相关子查询

> 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联查询。
>
> 简而言之：就是子查询中使用主查询中的列。

```sql
#题目：查询员工中工资大于本部门平均工资的员工的last_name，salary和其department_id
#方式一：使用相关子查询
SELECT last_name,salary,department_id
FROM employees e1
WHERE salary > (
									SELECT AVG(salary)
									FROM employees e2
									WHERE department_id = e1.department_id
							 );
#方式二：在FROM中声明子查询
SELECT last_name,salary,e.department_id
FROM employees e JOIN (
												SELECT department_id,AVG(salary) 'avg_sal'
												FROM employees
												GROUP BY department_id ) t_dept_avg_sal
-- WHERE e.department_id = t_dept_avg_sal.department_id
-- AND e.salary > t_dept_avg_sal.avg_sal;
ON e.department_id = t_dept_avg_sal.department_id
WHERE e.salary > t_dept_avg_sal.avg_sal;

```

```sql
# 查询员工的id，salary，按照department_name排序
# department_name 在departments表中
SELECT employee_id,salary
FROM employees e
ORDER BY (
					SELECT department_name
					FROM departments d
					WHERE e.department_id = d.department_id
				 )ASC;
```

```sql
# 若employees表中employee_id与job_history表中employee_id相同的数目不小于2
# 输出这些相同id的员工的employee_id，last_name和其job_id
SELECT employee_id,last_name,job_id
FROM employees e
WHERE 2 <= (
							SELECT COUNT(*)
							FROM job_history j
							WHERE e.employee_id = j.employee_id
					 );
```

> 结论：在SELECT中，除了GROUP BY和LIMIT之外，其他位置都可以声明子查询。

