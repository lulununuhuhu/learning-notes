# 存储过程和函数

MySQL从5.0版本开始支持存储过程和函数，存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部的SQL逻辑，而只是简单地调用存储过程和函数即可。

## 存储过程的概述

>  存储过程（stored procedure）,简单说来就是一系列SQL语句的封装,形成一个类似函数的功能。执行过程中，客户端向服务器发送调用存储过程的请求，服务器就可通过这一系列SQL语句组成的存储完成请求。
>
> 不过相较于函数，存储过程是**没有返回值**的。

## 创建和调用存储过程

### 语法 

```sql
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) 
[characteristics ...] 
BEGIN
	存储过程体 
END
```

说明:

1. `IN`:当前参数为输入参数，也是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是IN，表示输入参数
2. `OUT`:当前参数为输出参数,也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了
3. `INOUT`:当前参数既可以为输入参数，也可以为输出参数
4. 形参类型可以是MySQL数据库中的任意类型
5. `characteristics`表示创建存储过程时指定的对存储过程的约束条件

### 代码案例

```sql
#类型1：无参数
# 例1：创建存储过程select_all_data()，查看 emps 表的所有数据

DELIMITER $

CREATE PROCEDURE select_all_data()
BEGIN
	SELECT * FROM employees;
END $

DELIMITER ;

#2.存储过程的调用
CALL select_all_data();

#3.创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值
DELIMITER $

CREATE PROCEDURE show_max_salary()
BEGIN
	SELECT MAX(salary)
	FROM employees;
END $

DELIMITER ;

#4. 调用show_max_salary()
CALL show_max_salary();

#类型2：带OUT
#例：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出
DELIMITER $

CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)
BEGIN
	SELECT MIN(salary) INTO ms
	FROM employees;
END $

DELIMITER ;
# 调用show_min_salary()
CALL show_min_salary(@ms);
#查看变量值
SELECT @ms;

#例:创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。
DELIMITER $

CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))
BEGIN
	SELECT salary FROM employees
	WHERE last_name = empname;
END $

DELIMITER ;

#调用show_someone_salary()
#方式一
CALL show_someone_salary('Abel');
#方式二
SET @empname = 'Abel';
CALL show_someone_salary(@empname);


#类型4：带IN和OUT
# 创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资
DELIMITER $

CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DECIMAL(10,2))
BEGIN
	SELECT salary INTO empsalary
	FROM employees
	WHERE last_name = empname;
END $

DELIMITER ;

# 调用
CALL show_someone_salary2('Abel',@empsalary);
SELECT @empsalary;

#类型5 带INOUT
#例：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。
DELIMITER $

CREATE PROCEDURE (INOUT empname VARCHAR(25))
BEGIN
	SELECT last_name
	FROM employees
	WHERE employee_id = (
											 SELECT manager_id
											 FROM employees
											 WHERE last_name  = empname
											);
END $

DELIMITER ;

#调用
SET @empname = 'Abel';
CALL show_mgr_name(@empname);
SELECT @empname;
```

### 如何调用

在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样 逐步推进 ，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。

前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。

## 存储函数的使用

> 前面学习了很多函数，使用这些函数可以对数据进行各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。

### 语法

```sql
CREATE FUNCTION 函数名(参数名 参数类型,...) 
RETURNS 返回值类型 [characteristics ...] 
BEGIN
	函数体 #函数体中肯定有 
	RETURN 语句 
END
```

说明：

1. 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数
2. RETURNS type语句表示函数返回数据的类型。RETURNS子句只能对FUNCTION做指定，对函数而言这是强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句
3. characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同
4. 函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END

### 存储函数的调用

在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存

储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL 

的 开发者定义的。

```sql
SELECT 函数名(实参列表)
```

```sql
# 案例
# 例1：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。
DELIMITER //
CREATE FUNCTION email_by_name() 
RETURNS VARCHAR(25) 
DETERMINISTIC 
CONTAINS SQL 
BEGIN
	RETURN (SELECT email FROM employees WHERE last_name = 'Abel'); 
END //
DELIMITER ;
#调用
SELECT email_by_name();

#例2:创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。
DELIMITER // 
CREATE FUNCTION email_by_id(emp_id INT) 
RETURNS VARCHAR(25) 
DETERMINISTIC 
CONTAINS SQL 
BEGIN
	RETURN (SELECT email FROM employees WHERE employee_id = emp_id); 
END // 
DELIMITER ;

#调用
SET @emp_id = 102; 
SELECT email_by_id(102);


#例3：
DELIMITER // 
CREATE FUNCTION count_by_id(dept_id INT) 
RETURNS INT 
LANGUAGE SQL 
NOT DETERMINISTIC 
READS SQL DATA 
SQL SECURITY DEFINER 
COMMENT '查询部门平均工资' 
BEGIN
	RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);
END // 
DELIMITER ;

#调用
SET @dept_id = 50; 
SELECT count_by_id(@dept_id);
```

> 注：若在创建存储函数中报错“ you might want to use the less safe  log_bin_trust_function_creators variable ”，有两种处理方法：
>
> 1. 方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”
> 2. 方式2：mysql> SET GLOBAL log_bin_trust_function_creators = 1; 



## 存储过程和函数的查看、修改、删除

MySQL中存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。

1. 使用SHOW CREATE语句查看存储过程和函数的创建信息

   ```sql
   SHOW CREATE PROCEDURE select_all_data;
   ```

2. 使用SHOW STATUS语句查看存储过程和函数的状态信息

   ```sql
   SHOW PROCEDURE STATUS;
   ```

3. 从information_schema.Routines表中查看存储过程和函数的信息

