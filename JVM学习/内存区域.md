内存区域，又称运行时数据区域。在jvm体系结构中，在类加载子系统之后，对该系统输出的内容在内存中进行管理。

![image-20230630180416770](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230630180416770.png)

一个基本的jvm内存区域划分的规范如下：

![image-20230630190630262](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230630190630262.png)

在物理实现上，不同的jvm以及不同的版本，实现的方式有些许不同，比如Hotspot JVM就把本地方法栈和虚拟机栈合二为一的进行了实现，但是它们都是基于相同的规划要求。JVM内存区域的划分在JDK1.7和JDK1.8之间有不同。

其中线程私有的有：程序计数器、虚拟机栈、本地方法栈

线程共享的有：堆、方法区、直接内存。

### 程序计数器

程序计数器是当前线程所执行的字节码的行号指示器。字节码解释器通过改变计数器的值选取下一条需要执行的字节码指令。

通过程序计数器可以实现常见的代码逻辑功能。

### Java虚拟机栈

线程私有，生命周期和线程相同。

Java方法的调用都通过虚拟机栈完成。每调用一个Java方法，会在栈中压入一个栈帧，方法结束则弹出栈。

栈由栈帧作为组成元素，栈帧中拥有局部变量表、操作数栈、动态链接、方法返回地址。

虚拟机栈会出现的两种错误：

`StackOverFlowError`:若栈的内存不大不允许动态扩展，那么线程请求栈的深度超过当前Java虚拟机栈的最大深度时就抛出该错误。

`OutOfMemmoryError`：如果栈的内存大小可以动态扩展，但是虚拟机在动态扩展栈时无法申请到足够的内存空间，就会抛出该错误。

### 本地方法栈

与Java虚拟机栈相似，但是服务对象是JDK的native方法

### 堆

线程共享

堆是用来管理所有对象实例的内存区域，也是垃圾收集器的主要区域。

堆内存区域基于分代垃圾回收算法，也细分为不同部分![image-20230630173056249](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230630173056249.png)

在JDK7及之前，堆内存被分为新生代、老年代、永久代三大部分。在JDK8之后，永久代被元空间所代替。

### 方法区

线程共享。

只是一个规范/抽象概念，在不同jdk版本下的虚拟机有不同的实现，jdk7之前方法区的实现是永久代，jdk8之后方法区的实现是元空间。

### 运行时常量池

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 

### 字符串常量池

专门存放String类对象的内存区域，主要目的是为了避免字符串的重复创建。

JDK6及之前，字符串常量池存放在永久代。jdk7及之后字 符串常量池和静态变量从永久代转到了堆中。

![image-20230630175303914](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230630175303914.png)

![image-20230630175312611](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230630175312611.png)

### 直接内存

一种特殊的内存缓冲区，并不在Java堆或方法区中分配的，而是通过JNI的方式在本地内存上分配的。

### Java对象的创建过程

1. 类加载检查

   检查创建对象的指令能否在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有的话，就先执行相应的类加载过程。

2. 分配内存

   为新生代的java对象分配内存。在类加载完成后就可确定内存的大小，按照这个大小为对象在堆中分配空间。分配方式有指针碰撞和空闲列表两种，选择哪两种方式由Java堆是否规整（没有内存碎片就是规整）决定，是否规整是由采用的垃圾收集器是否带有压缩整理功能决定。

3. 初始化零值

4. 设置对象头

   对对象进行必要的设置，将设置信息存放到对象头中

5. 执行init方法

   执行<init>方法后，将对象按程序员的意愿进行初始化