#  拦截器

##  1、拦截器的配置

SpringMVC中的拦截器用于拦截控制器方法的执行，可以看成是作用在HTTP和DispatcherServlet之间的一个拦截不明的HTTP请求的一个功能。

SpringMVC中的拦截器需要实现HandlerInterceptor或者继承HandlerInterceptorAdapter类。

SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：

```xml
    <mvc:interceptors>
<!--        <bean class="interceptors.FirstInterceptor"></bean>-->
<!--        <ref bean="firstInterceptor"></ref>-->
<!--        以上两种方式都是实现拦截所有请求的效果-->
<!--        配置方式三：配置具体的拦截路径：拦截所有但不包括/初始路径-->
        <mvc:interceptor>
            <mvc:mapping path="/**"/>
            <mvc:exclude-mapping path="/"/>
            <ref bean="firstInterceptor"></ref>
        </mvc:interceptor>
    </mvc:interceptors>
```

## 2、拦截器的三个抽象方法

SpringMVC中的拦截器有三个抽象方法：

1. preHandle:控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回为true即放行；返回为false即拦截，即不调用控制器方法
2. postHandle：控制器方法执行之后执行postHandle()
3. afterComplation:处理完视图和模型数据，渲染视图完毕之后执行afterComplation()

## 3、多个拦截器的执行顺序

若每个拦截器的preHandle()都返回true，此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行。

```java
boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
    for(int i = 0; i < this.interceptorList.size(); this.interceptorIndex = i++) {
        HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i);
        if (!interceptor.preHandle(request, response, this.handler)) {
            this.triggerAfterCompletion(request, response, (Exception)null);
            return false;
        }
    }
    return true;
}
```

```java
void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception {
    for(int i = this.interceptorList.size() - 1; i >= 0; --i) {
        HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i);
        interceptor.postHandle(request, response, this.handler, mv);
    }

}

void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) {
    for(int i = this.interceptorIndex; i >= 0; --i) {
        HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i);

        try {
            interceptor.afterCompletion(request, response, this.handler, ex);
        } catch (Throwable var7) {
            logger.error("HandlerInterceptor.afterCompletion threw exception", var7);
        }
    }

}
```

若某个拦截器的preHandle()返回了false，preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行。

```java
void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) {
   for (int i = this.interceptorIndex; i >= 0; i--) {
      HandlerInterceptor interceptor = this.interceptorList.get(i);
      try {
         interceptor.afterCompletion(request, response, this.handler, ex);
      }
      catch (Throwable ex2) {
         logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
      }
   }
}
```

