## Java基础中常见的面试题

### JavaSE

#### 说一下java/jvm的内存划分?

>java的内存划分为虚拟机栈、方法区、堆、程序计数器、本地方法栈五个部分。
>
>虚拟机栈：基本单位是栈帧，有入栈出栈的操作。一个栈帧通常对应着一个方法的执行，方法中的局部变量和方法就存放在栈帧中。入栈对应着方法的开始执行，出栈对应着方法的结束。
>
>本地方法栈：调用方法区中的一些方法
>
>方法区：存放本地的一些c语言生成的方法
>
>堆：用来存放类的实现对象的内容以及字符串常量池
>
>程序计数器：记录当前程序在内存中执行到的位置，方便程序被中断后回来，继续从原来的位置执行
>
>![image-20230223121559500](C:/Users/lucheng/AppData/Roaming/Typora/typora-user-images/image-20230223121559500.png)

#### 说明Java的值传递机制

>java的值传递是java中参数传递的唯一一种方法，就是将**实参的副本**传给方法的形参，原实参对应不受影响。
>
>对于基本数据类型来说，传的实参是**数据的值**；
>
>对应引用数据类型来说，传的实参是**引用对象在内存中的地址值**

具体例子:

```java
public class demo {
    public static void main(String[] args) {
        String str = "str";
        int[] arg = new int[]{1,2,3};
        demo demo = new demo();
        demo.exchange(str,arg); //这是实参是str 和 arg
        System.out.println("str = "+str);//str = str
        System.out.println("arg = "+arg[0]); // arg = [3,2,3]
        int x = 5,y = 8;
        demo.exchange(x,y);
        System.out.println("x = "+x+" y = "+y); // x = 5  y = 8
    }

    //形参是str 和 arg,他们是是实参的副本，而他们被赋予实参的值后如果更改的话原形参的值不会收到影响
    public void exchange(String str,int[] arg){
        str = "ok";
        arg[0] = 3;
    }
    public void exchange(int a,int b){
        int tmp = b;
        b = a;
        a = tmp;
    }
}
```

#### 方法的重载和重写

> 方法的重载就是在同一个类中可以有**同样的方法名**，但他们的**形参列表必须不同**，**与返回类型无关，与权限修饰符无关**。
>
> 方法的重写就是在子类重新定义父类相同方法名的方法体。遵从**两同两小一大**原则
>
> ​	两同：方法名相同，参数列表相同。
>
> ​	两小：子类返回值类型**小于等于**父类返回值类型
>
> ​			    子类的抛出异常**小于等于**父类抛出的异常
>
> ​	一大：子类访问控制修饰符的范围**大于等于**父类访问控制修饰符范围

#### 封装型的定义和体现

> 封装就是将某些方法的内部具体实现细节隐藏起来，不对外暴露，只对外提供方法功能的调用。这样可以保证程序的安全性和通用性。
>
> 实现封装采用的是四种权限修饰符 public protected 缺省(default) private 权限等级由高到低。
>
> public default可以修饰类
>
> public protected 缺省(default) private 可以修饰成员变量 成员方法 构造器 成员内部类
>
> |           | 类内部 | 同一个包 | 其他包的子类 | 其他包非子类 |
> | --------- | ------ | -------- | ------------ | ------------ |
> | public    | √      | √        | √            | √            |
> | protected | √      | √        | √            | ×            |
> | default   | √      | √        | ×            | ×            |
> | private   | √      | ×        | ×            | ×            |

#### 说一下对final关键字的理解

> final可以修饰的结构：类、方法、变量
>
> ​	final修饰类时：表示该类不能被继承。比如String类、StringBuilder类、StringBuffer类
>
> ​	final修饰方法时：表示该方法不能被重写。比如Object中的getClass方法
>
> ​	final修饰变量时：一旦被赋值，就不能再更改，且变量必须显示赋值，没有默认值。
>
> final和static搭配时，一般修饰成员变量，作为全局常量使用。

#### 实例化类对象时成员的初始化顺序

> 结论:初始化优先级来说：静态成员变量初始化>静态代码块> 成员初始化 > 非静态代码块 > 构造器。如果实例化对象有父类时，父类静态成员>父类静态代码块>子类静态成员>子类静态代码块>父类成员初始化>父类非静态代码块>父类构造器>子类成员初始化>子类非静态代码块>子类构造器
>
> ```java
> public class Ancestor {
>  private String country = "中国";
> 
>  public Ancestor() {
>      System.out.println("Ancestor类的空参构造方法");
>  }
> 
>  static {
>      System.out.println("执行Ancestor类的静态代码块");
>  }
>  {
>      System.out.println("country = "+country);
>      System.out.println("执行Demo类的非静态代码块");
>  }
> }
> public class Demo extends Ancestor{
>  private int age = 5;
>  private String name = "lucheng";
> 
>  public Demo() {
>      System.out.println("demo类空参构造方法");
>  }
> 
>  //静态代码块
>  static {
>      System.out.println("执行demo类的静态代码块");
>  }
> 
>  //非静态代码块
>  {
>      System.out.println("age = "+age+", name = "+name);
>      System.out.println("执行Demo类的非静态代码块");
>  }
> 
>  public static void main(String[] args) {
>      Demo demo = new Demo();
>  }
> }
> 
> //执行结果
> 执行Ancestor类的静态代码块
> 执行demo类的静态代码块
> country = 中国
> 执行Demo类的非静态代码块
> Ancestor类的空参构造方法
> age = 5, name = lucheng
> 执行Demo类的非静态代码块
> demo类空参构造方法
> 
> 
> ```
>

#### 说一下abstract关键字

abstract修饰类：

* 表示该类是抽象类，不能实例化
* 子类实现抽象类中的所有抽象方法，才能不是抽象类

abstract修饰方法：

* 该方法不能有方法体
* 该方法需要由子类重写

#### 接口和抽象类的区别

* 接口中只能定义抽象方法，而抽象类中可以有具体方法；

* 接口中只能定义静态全局常量，而抽象类可以定义普通成员变量；

* 接口与接口之间可以多继承`implements A,B`，而抽象类只能单继承`extends C`；

#### 类型转换

基本类型标识范围由低到高依次为 char/short/byte  < int < long < float < double。低范围数据类型转成高范围数据类型可以隐式转换；高范围数据类型转化为低范围数据类型需要强转

```java
int a = 3;
long b = a;//int 隐式转换为 long类型

double c = 3.2;
float d = (float) c;// double 强转为 float类型
```

java中整型默认的数据类型是int，浮点数默认的数据类型是double。所以在定义整数时，设置的变量为int；如果是级别比int小的话，需要强转。定义浮点数也是同理。

```java
byte a = 5;//编译通不过，整数类型数字默认是int类型
byte b = (btye)5;//编译通过，整数类型强转为byte类型
```

### String str = new String("abc")过程中创建了几个内存对象

> 创建了两个内存对象。使用new在堆中新建了一个String类对象，栈中的变量指向String类对象的地址；同时在字符串常量池中创建一个常量字符串"abc"，对象的中value属性的值指向该常量字符串的地址。

### 字符串不同拼接情况下返回的地址类型

```java
String s1 = "coder";
String s2 = "coder";
String s3 = "coder"+s2;
String s4 = "coder"+"coder";//常量+常量
String s5 = s1+s2;//变量+变量
System.out.println(s3 == s4);//false
System.out.println(s3 == s5);//false
System.out.println(s4 == "codercoder");//true
```

总结：

* 使用常量+常量拼接字符串时，返回的是**拼接后的字符串**在常量池的中地址值,这是在编译期间就执行的
* 使用变量+常量/变量+变量拼接字符串时，返回的是一个新的new出来的对象的地址值，这是因为在拼接字符串中有变量时，编译器会在编译时会优化成使用StringBuilder对象来进行拼接，然后拼接完成后调用StringBuilder的toString方法转化成字符串，而StringBuilder中的toString方法的实现就是返回一个新的String对象。

```
 NEW java/lang/StringBuilder
    DUP
    INVOKESPECIAL java/lang/StringBuilder.<init> ()V
    LDC "coder"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    ALOAD 2
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
```

```java
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
```

### String、StringBuilder、StringBuffer的区别

相同点：都是用来操作字符串的类

不同点：

1. 不可变性

   使用String类声明的字符串存放在字符串常量池中，一旦声明了之后就不可修改。而StringBuffer和StringBuilder都支持对字符串的动态增删改。

2. 线程安全性

   String类字符串一旦声明就不可更改，所以任意线程访问这个String都不会产生线程安全。StringBuilder在多线程情况下会有线程安全问题，StringBuffer在多线程情况下没有线程安全问题，因为在对字符串的增删改的方法中都使用了synchronized修饰

3. 性能
   String类中同一个字符串之创建一次，避免了多次创建重复对象的开销，性能比较好。

#### wait()和sleep()的区别

在使用位置上：wait()只能在同步代码块或者同步方法中使用；sleep()可以在任何位置使用

在方法声明位置上：wait()是Object类的方法；sleep()是Thread类的方法

在使用效果上:wait()是让当前执行同步代码的线程进入阻塞状态，同时**释放同步监视器**，如果没有设置参数，则需要等待其他线程使用notify()或notifyAll()方法唤醒。sleep()是让当前线程休眠一段时间，并且如果拥有同步监视器的话**不会释放同步监视器**，直到休眠结束，继续执行同步代码块的剩余代码或者进入就绪态。

### 集合

#### arraylist linkedlist hashset的区别和使用场景

#### 讲一下hashset的底层原理

#### hashmap的底层实现



### IO

### 网络编程

