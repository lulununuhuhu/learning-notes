> 当一个类的对象只有有限个、确定的时候，我们称此类为枚举类；当需要定义一组常量时，强烈建议使用枚举类；若枚举类只有一个对象，则可以作为单例模式的一种实现方式。

## 自定义枚举类

jdk5.0之前还没有专门的enum关键字对枚举类进行申明。下面说下自定义枚举类的步骤：

1. 申明类的属性，用`private final`修饰
2. 创建私有化的构造器，并给对象属性赋值
3. 创建当前类的多个对象，使用`public static final`修饰对象
4. 重写`toString`方法
5. 在main方法中使用**类.类对象**的方式进行调用对象

```java
class season{
    //1、声明属性，用private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //2、使用私有构造器对final属性进行赋值
    private season(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    //3、创建当前类对象，用static final 修饰
    public static final season SPRING = new season("春天","春暖花开");
    public static final season SUMMER = new season("夏天","夏日炎炎");
    public static final season AUTUMN = new season("秋天","秋高气爽");
    public static final season WINTER = new season("冬天","寒冬将至");

    //4、重写toString方法
    @Override
    public String toString() {
        return "season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }

}
```

## 使用enum关键字定义枚举类

定义的枚举类默认继承于`java.lang.Enum`类，enum最大的特点就是不需要显示的声明类对象，可通过在类最前面提供当前枚举类的对象，使用枚举对象名(构造方法形参)的方式即可创建，多个对象用使用;

```java
enum season1{
    //在类中最前面提供当前枚举类的对象，多个对象用,隔开，最后用;
    SPRING("春天","春暖花开"),
    SUMMER("夏天","夏日炎炎"),
    AUTUMN("秋天","秋高气爽"),
    WINTER("冬天","冬意绵绵");

    private final String seasonName;
    private final String seasonDesc;

    private season1(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
  }
```

## Enum类中的常用方法

1. `values()`：返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值。
2. `valueOf(String str)`：可以把一个字符串str转为对应的枚举类对象并返回
3. `toString()`：返回当前枚举类对象常量的名称

## Enum类中的接口实现方法

1. 和类的实现方式相似
2. 在每一个枚举类中分别实现接口的实现方法

```java
SPRING("春天","春暖花开"){
    @Override//不同的枚举类实现不同的接口实现方法
    public void show() {
        System.out.println("春天在哪里");
    }
},
SUMMER("夏天","夏日炎炎") {
    @Override
    public void show() {
        System.out.println("粉红的回忆");
    }
},
AUTUMN("秋天","秋高气爽") {
    @Override
    public void show() {
        System.out.println("秋天不回来");
    }
},
WINTER("冬天","冬意绵绵") {
    @Override
    public void show() {
        System.out.println("大约在冬季");
    }
};
```

## 注解

JDK5.0之后，Java增加了对Annotation注解的支持。

> Annotation是代码里的特殊标记，这些标记可以在扁编译，类加载，运行时被读取并执行相应的处理。通过使用Annotation。程序员可在不改变代码逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。
>
> 现在和未来的开发模式中，注解扮演着重要的角色。例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁杂代码和XML配置等。可以说，框架=注解+反射+设计模式

## 常见的注解实例

1. 生成文档相关的注解

![image-20211115125549096](C:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211115125549096.png)

2. 在编译时进行格式检查（JDK内置的三个基本注解）
   1. @Override:限定重写父类方法，该注解只能用于方法
   2. @Deprecated：用于表示所修饰的元素(类、方法等)已过时。通常是因为有更好的选择可代替
   3. @SuppressWarnings：抑制编译器警告，即将原本编译器会出现警告的情况取消掉提醒，如使用`SuppressWarnings("unused")`:对于某些已定义但从未使用过的这类警告屏蔽掉。
3. 跟踪代码依赖性，实现替代配置文件的功能

![image-20211115130635385](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211115130635385.png)

## 自定义注解方法

1. 注解声明为@interface
2. 内部定义成员通常使用value表示
3. 可以指定成员的默认值使用default定义
4. 如果自定义注解没有成员表明是一个标识作用
5. 如果注解有成员在使用注解时，需要指明成员的值；自定义注解必须配上注解的信息处理流程（使用流程）才有意义。
6. 自定义注解通常都会指明两个元注解：`Retention` `Target`

```java
package Annotation;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * 自定义注解
 */
@Retention(RetentionPolicy.RUNTIME)//定义注解的生命周期
public @interface CustomizeAnnotation {
    String value();
}
```

## JDK中的元注解

JDK的元Annotation用来修饰Annotation的注解，是最基本的注解类型。

JDK5.0提供了4个标准的meta_annotation类型,分别是

* `Retention` ：指定所修饰的Annotation的三种生命周期：SOURCE\CLASS(默认周期)\RUNTIME,只有声明为RUNTIME生命周期的注解，才能通过反射获取。SOURCE是指在编译时不会读取该注解，CLASS是指在编译时读取该注解信息，但到执行时，不会调用到内存中。

* `Target`：用于指定被修饰的Annotation能用于修饰哪些程序元素（类/方法/属性/构造器）
*  `Documented` :有该注解时表示所修饰的注解在javadoc解析时保留下来
* `Inherited`：有该注解时该Annotation具有继承性，使用该Annotation的类的子类也同样应用该Annotation

```java
@Target({ElementType.FIELD,ElementType.CONSTRUCTOR,ElementType.METHOD})//该注解指定了@demo1注解可申明的结构类型为属性、构造器、方法
@Retention(RetentionPolicy.RUNTIME) //该注解申明了@demo1的声明周期为Runtime，即在运行时该注解仍然能调用
public @interface demo1 {
    String value() default "haha";
}
public class demo {
    @demo1  //该注解可以申明在属性上
    private int age;

    @demo1
    public demo(int age) {
        this.age = age;
    }

    @demo1 //该注解可以申明在方法上
    public void show(){
        System.out.println("hello world");
    }
}
```

## JDK中的新注解:可重复注解

1. 在MyAnnotation上声明@Repeatable。成员值为MyAnnotations.class
2. 在MyAnnotation的Target和Retention等元注解属性和MyAnnotations相同

