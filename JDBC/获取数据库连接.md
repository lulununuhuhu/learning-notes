[TOC]

## 获取数据库连接

1. 导入JDBC驱动的jar包

> JDBC并不能直接访问我们的数据库，必须依赖数据库厂商提供的JDBC驱动程序，下面以Mysql为例，下载Mysql的JDBC的驱动的jar包。

		1. JDBC驱动jar包在Mysql下载根目录的MySQL\Connector J 8.0路径中，我下载的Mysql的jdbc驱动程序jar包是

![image-20211022201951007](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211022201951007.png)

2. 导入jar包

   file——>project structure——>modules

![image-20211022202607042](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211022202607042.png)

​		点击+中的第一个添加JARS，将Jar包路径添加进去即完成。



###  要素一：Driver接口实现类

* java.sql.Driver是JDBC驱动程序需要实现的接口。这个接口面向数据库厂商，不同的厂商根据自己的数据库特点进行实现。

* 在开发程序中不需要直接访问驱动程序实现类，而是通过由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。
  * mysql的驱动：`com.mysql.jdbc.Driver`或者`com.mysql.cj.jdbc.Driver`
  * oracle的驱动：`com.mysql.jdbc.Driver`

### 要素二: URL

URL作为用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。

URL的组成：主协议(jdbc):子协议(mysql)://ip地址(localhost):端口号(localhost)/数据库名(test)

### 要素三：用户名和密码

- user,password可以用“属性名=属性值”方式告诉数据库
- 可以调用 DriverManager 类的 getConnection(url,user,password) 方法将用户名密码赋给形参建立到数据库的连接



## 数据库连接方式举例

### 方式一

```java
Driver driver = new com.mysql.cj.jdbc.Driver();
//jdbc主协议:mysql子协议://localhostip地址:3306端口号/数据库名
String url = "jdbc:mysql://localhost:3306/myemployees";
//通过Properties获取数据库用户名和密码
Properties info = new Properties();
info.setProperty("user","root");
info.setProperty("password","13921350895lc");
Connection conn = driver.connect(url, info);
System.out.println(conn);
```

### 方式二

通过反射将第三方的API封装起来，这样便于程序移植。

```java
//通过反射获取Driver实现类对象
Class aClass = Class.forName("com.mysql.cj.jdbc.Driver");
Driver driver = (Driver) aClass.getDeclaredConstructor().newInstance();

String url = "jdbc:mysql://localhost:3306/myemployees";
Properties info = new Properties();
info.setProperty("user","root");
info.setProperty("password","13921350895lc");
Connection conn = driver.connect(url, info);
```

### 方式三

使用DriverManager替换Driver

```java
//获取Driver实现类的对象
Class aClass = Class.forName("com.mysql.cj.jdbc.Driver");
Driver driver = (Driver) aClass.getDeclaredConstructor().newInstance();
//提供另外三个连接的基本参数
String url = "jdbc:mysql://localhost:3306/myemployees";
String user = "root";
String password = "13921350895lc";

//注册驱动
DriverManager.registerDriver(driver);
//获取连接
Connection conn = DriverManager.getConnection(url, user, password);
```

### 方式四

相较于方式三，可以省去手动注册驱动的步骤，因为Driver类中有静态方法在加载式进行了注册的动作。

```java
//加载Driver
Class.forName("com.mysql.cj.jdbc.Driver");

//提供另外三个连接的基本参数
String url = "jdbc:mysql://localhost:3306/myemployees";
String user = "root";
String password = "13921350895lc";
//获取连接
Connection conn = DriverManager.getConnection(url, user, password);
```

### 方式五

将数据库的参数写入配置文件中通过读取配置文件的参数来进行连接

```java
//读取配置文件参数
InputStream inputStream = ConnectionTest1.class.getClassLoader().getResourceAsStream("info.properties");
Properties properties = new Properties();
properties.load(inputStream);

String user = properties.getProperty("user");
String password = properties.getProperty("password");
String driver = properties.getProperty("driver");
String url = properties.getProperty("url");

//加载驱动
Class.forName(driver);

//获取连接
Connection conn = DriverManager.getConnection(url, user, password);
```

## 使用PreparedStatement实现CRUD操作

首先我们以面向对象的角度来对数据库和Java做一个联系：

* 一张数据库的表对应一个类
* 表中的一段数据对应类的一个实例
* 表中的字段对应类的一个属性

这就是ORM(Object relational mapping)编程思想。

**PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句**

CRUD即增删改查操作，其中增删改可以划分一类，改划分为另一类。增删改是像数据库注入SQL语句并执行，查是查询数据库某个表记录并返回到程序中。

### PreparedStatement对于Statement的优势

1. Statement通过执行静态的SQL语句进行操作`int excuteUpdate(String sql)``ResultSet excuteQuery(String sql)`，每次都要输入完整的sql语句，较为繁琐
2. PreparedStatements采用sql语句预编译的方式，先传入基本sql语句的骨架如`select id,name,birth from customers where id = ?`,其中的？可以通过`setObject()`方法进行传入，这样灵活性可大大提高。
3. Statement存在SQL注入问题：即数据库系统对执行的sql语句格式没有充分的检查，在用户输入的一些语句中的参数与sql的关键字发生冲突，导致执行了意想不到的功能的情况。

在上述连接数据库方式五的基础上：

1. 执行sql语句预编译,获取PreparedStatement对象

   ```java
   PreparedStatement ps = null;
   String sql = "insert into customers(name,email,birth)value(?,?,?)";//?占位符 在customes表中插入一条数据
   ps = conn.prepareStatement(sql);
   ```

2. 填充占位符

   ```java
   ps.setString(1,"刘强东");
   ps.setString(2,"105689702@qq.com");
   SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
   java.util.Date date =  sdf.parse("1987-05-04");
   ps.setDate(3, new java.sql.Date(date.getTime()));//第二个参数时java.sql.Date类
   ```

3. 执行sql操作

   ```java
   ps.execute();
   ```

4. 关闭资源

   ```java
   ps.close();
   conn.close();
   ```

整体代码：

```java
//向数据库表中添加数据
@Test
public void Test() {
    PreparedStatement ps = null;
    Connection conn = null;
    try {
        //读取配置文件参数
        InputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream("info.properties");
        Properties properties = new Properties();
        properties.load(inputStream);

        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        Class.forName(driver);        //加载驱动
        conn = DriverManager.getConnection(url, user, password);        //获取连接

        //执行sql语句预编译,获取PreparedStatement对象
        String sql = "insert into customers(name,email,birth)value(?,?,?)";//?占位符
        ps = conn.prepareStatement(sql);

        //填充占位符
        ps.setString(1,"刘强东");
        ps.setString(2,"105689702@qq.com");
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        java.util.Date date =  sdf.parse("1987-05-04");
        ps.setDate(3, new java.sql.Date(date.getTime()));//第二个参数时java.sql.Date类
        //执行操作
        ps.execute();
    } catch (Exception e) {
        e.printStackTrace();
    } 
    }finally {
        //资源的关闭
        try {
            if(conn != null)
                conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        try {
            if(ps != null)
                 ps.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}
```

### Java与SQL对应数据类型转换表

| Java类型           | SQL类型                  |
| ------------------ | ------------------------ |
| boolean            | BIT                      |
| byte               | TINYINT                  |
| short              | SMALLINT                 |
| int                | INTEGER                  |
| long               | BIGINT                   |
| String             | CHAR,VARCHAR,LONGVARCHAR |
| byte   array       | BINARY  ,    VAR BINARY  |
| java.sql.Date      | DATE                     |
| java.sql.Time      | TIME                     |
| java.sql.Timestamp | TIMESTAMP                |

### 通用的增删改操作

```java
/**
 * 通用的增删改操作
 * @param sql 具体操作sql语句
 * @param args 可变数组在占位符的数据
 */
public static int updateDB(String sql,Object ...args){
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = JDBCUtil.getConnection();
        ps = conn.prepareStatement(sql);
        //设置占位符
        for (int i = 0; i < args.length; i++) {
            ps.setObject(i+1,args[i]);
        }
        //执行sql语句
        /*
        方式一：返回类型是Boolean型，如果是查询操作返回true，如果是增删改操作则返回false
         */
        //ps.execute();
        /*
        方式二：返回类型是int，返回的是sql数据状态的行数，0表示没有操作
         */
         int res = ps.executeUpdate();
         return res;
    } catch (SQLException throwables) {
        throwables.printStackTrace();
    }finally {
        JDBCUtil.closeConnection(conn,ps);
    }
    return 0;
}
```

### 通用查询操作

```java
public static Customers queryDB(String sql,Object ...args){
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet resultSet = null;//执行查询返回ResultSet结果集
    try {
        conn = JDBCUtil.getConnection();
        ps = conn.prepareStatement(sql);
        for (int i = 0; i < args.length; i++) {
            ps.setObject(i+1,args[i]);//设置占位符
        }
        resultSet = ps.executeQuery();
        ResultSetMetaData metaData = resultSet.getMetaData();//获取结果集的元数据
        int columnCount = metaData.getColumnCount();//通过metaData获取结果集的列数

        if(resultSet.next()){
            Customers customers = new Customers();
            for (int i = 0; i < columnCount; i++) {
                Object columnValue = resultSet.getObject(i + 1);//获取列值
               //String columnName = metaData.getColumnName(i + 1);//获取每个列的列名

      //在数据库表中的字段名和属性名不一致的情况下，可以在sql语句中使用别名从而将字段名和类属性联系在一起
                String columnLabel = metaData.getColumnLabel(i+1);//获取每列的别名
      //通过反射给customers对象指定的columnLabel属性赋值为columnValue
                Field field = Customers.class.getDeclaredField(columnLabel);
                field.setAccessible(true);
                field.set(customers,columnValue);
            }
            return customers;
        }
    } catch (Exception throwables) {
        throwables.printStackTrace();
    } finally {
        JDBCUtil.closeConnection(conn,ps,resultSet);
    }
    return  null;
}
```

### 图解表查询流程

![image-20211026212102496](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211026212102496.png)

## 操作数据库中的Blob数据类型字段

* MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，他能容纳不同大小的数据
* 插入BLOB类型的数据必须使用`PrepareStatement`,因为BLOB类型的数据无法使用字符串拼接

MySQL有四种BLOB类型

| Blob类型   | 容纳数据大小（字节） |
| ---------- | -------------------- |
| TinyBlob   | 最大255              |
| Blob       | 最大65K              |
| MediumBlob | 最大16M              |
| LongBlob   | 最大4G               |

注：

1. 实际存储中根据数据大小选择对应的Blob类型；
2. 存储文件过大，数据库的性能会下降；
3. 使用满足要求的Blob类型后，仍会出现类似xxx too large，在mysql的安装目录下，找到my.ini文件加上如下的配置参数`max_allowed_packet=16M`。修改了配置之后需重启mysql服务才生效。

### 向数据表中添加Blob类型的字段

```java
Connection conn = JDBCUtil.getConnection();
String sql = "insert into customers (name,email,birth,photo)values(?,?,?,?)";
PreparedStatement ps = conn.prepareStatement(sql);//预编译sql语句
//设置占位符
ps.setObject(1,"路程");
ps.setObject(2,"1078496642@qq.com");
ps.setObject(3,"1997-06-21");
FileInputStream is = new FileInputStream(new File("photo.jpg"));
ps.setBlob(4,is);
ps.execute();//执行sql指令
JDBCUtil.closeConnection(conn,ps);
```

### 在数据库中修改Blob类型字段

```java
Connection conn = JDBCUtils.getConnection();
String sql = "update customers set photo = ? where id = ?";
PreparedStatement ps = conn.prepareStatement(sql);

// 填充占位符
// 操作Blob类型的变量
FileInputStream fis = new FileInputStream("coffee.png");
ps.setBlob(1, fis);
ps.setInt(2, 25);

ps.execute();

fis.close();
JDBCUtils.closeResource(conn, ps);
```

### 查询数据表中的Blob类型字段并保存到文件中

```java
    InputStream is = null;
    FileOutputStream fos = null;
    PreparedStatement ps = null;
    Connection conn = JDBCUtil.getConnection();

    String sql = "select id,name,email,birth,photo from customers where id = ?";
    try {
        ps = conn.prepareStatement(sql);
        ps.setObject(1,21);//设置占位符
        ResultSet rs = ps.executeQuery();
        if(rs.next()){
            int id = rs.getInt("id");
            String name = rs.getString("name");
            String email = rs.getString("email");
            Date birth = rs.getDate("birth");

            Customers cus = new Customers(id,name,email,birth);
            System.out.println(cus);
            //将Blob类型的字段数据下载下来并保存到本地
            Blob photo = rs.getBlob("photo");
            is = photo.getBinaryStream();
            fos = new FileOutputStream("lucheng.jpg");
            byte[] buffer = new byte[1024];
            int len;
            while((len = is.read(buffer))!=-1)
                fos.write(buffer,0,len);
            JDBCUtil.closeConnection(conn,ps,rs);
        }
    } catch (Exception throwables) {
        throwables.printStackTrace();
    } finally {
        try {
            if(is != null)
               is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            if(fos != null)
                fos.close();//相关的文件输出输入流关闭
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 数据库事务

### 什么是事务

> 事务：一组逻辑操作单元，使数据从一种状态转换为另一种状态，其中一组逻辑操作单元有一个或多个DML语言
>
> 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使执行过程中出现错误，也不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交（commit）**，这些修改就保存下来；要么数据库管理系统放弃所有的修改，整个事务能**回滚（rollback）**到最初状态。
>
> 为确保数据库中数据的一致性，数据的操纵应该是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持；而这个单元中的一部分操作失败，则整个事务应视为错误，所有从起始点以后的操作应全部回退到开始状态。

### JDBC事务处理

> 数据一旦被提交（commit）,意味着不可撤销更改。

数据什么时候意味着提交？

* **当一个连接对象被创建后，默认的是自动提交事务**；每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。

* **关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务一致。即同一个事务的多个操作必须在同一个连接下。
* DML语言如insert、delete、update等默认情况下每执行完一条就会自动提交：autocommit = true
* DDL语言如CREATE TABLE/VIEW等是隐形提交，不能*回滚（roll back）**

```java
String sql1 = "update user_table set balance =balance-100 where user=?";
String sql2 = "update user_table set balance=balance+100 where user=?";
ps = conn.prepareStatement(sql1);
ps.setString(1,"AA");
ps.execute();
System.out.println(10/0);//程序会产生除零异常，会意外终止
ps = conn.prepareStatement(sql2);
ps.setString(1,"BB");
ps.execute();
```

上述程序中由于会意外终止，代码不会执行balance加100的操作，此时需要将这两条sql语句组成事务，要么一起执行，要么出错后回滚到执行前状态。

JDBC中让多个Sql语句作为一个事务执行的方法是：

1. 调用Connection对象的`setAutoCommit(false)`:以取消自动提交事务
2. 在所有的sql语句都执行成功后，调用`commit()`方法提交事务
3. 在出现异常时，调用`rollback()`方法回滚事务

注：若此时Connection没有被关闭，还有可能被重复使用，为了后续的SQL语句执行，需要恢复其自动提交状态。尤其在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。

```java
Connection conn = Unity.getConnection();
PreparedStatement ps = null;
try {
    conn.setAutoCommit(false);//将DML语言的自动提交关闭
    String sql1 = "update user_table set balance =balance-100 where user=?";
    String sql2 = "update user_table set balance=balance+100 where user=?";
    ps = conn.prepareStatement(sql1);
    ps.setString(1,"AA");
    ps.execute();
    System.out.println(10/0);
    ps = conn.prepareStatement(sql2);
    ps.setString(1,"BB");
    ps.execute();
    conn.commit();//事务提交
} catch (Exception throwables) {
    //抛出异常，回滚到事务前
    try {
        conn.rollback();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    throwables.printStackTrace();
}finally {
    Unity.closeConnection(conn,ps);
}
```

### 事务的ACID属性

* 原子性(Atomicity)：事务作为执行的最小单元，具有不可分割性
* 一致性(Consistency):事务必须使数据库从一个一致性状态变换到另外一个一致性状态
* 隔离性(Isolation)：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作和使用的数据其他事务不能干扰，并发执行的各个事务之间不能互相干扰
* 持久性(Durabiliity)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

### 数据库的并发问题

- 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:
  - **脏读**: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。
  - **不可重复读**: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 **更新**了该字段。之后, T1再次读取同一个字段, 值就不同了。
  - **幻读**: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。
- **数据库事务的隔离性**: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。
- 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱。**

| 隔离级别                       | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| READ UNCOMMITTED(读未提交数据) | 允许事务读取未被其他事务提交的变更，会出现脏读、不可重复读和幻读的问题 |
| READCOMMITED(读已提交数据)     | 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读问题仍然可能出现 |
| REPEATABLEREAD(可重复读)       | 确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在 |
| SERIALIZABLE(串行化)           | 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，但性能低下 |

在以上四种隔离级别中，Oracle支持的2种事务隔离级别：**READ COMMITTED** **SERIALIZABLE**。Oracle默认的事务隔离级别是**READ COMMITTED**。Mysql支持以上4种隔离级别，Mysql默认的事务隔离级别为**REPEATABLE READ**

### 事务相关的命令

每启动一个MySQL程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量`@@transaction_isolation`，表示当前的事务隔离级别

* 设置全局的事务隔离级别

```sql
set global transaction isolation level 隔离级别(read committed);
```

* 设置当前库的事务隔离级别

```sql
set transaction isolation level 隔离级别
```

* 查看当前库的事务隔离级别

```sql
select @@transaction_isolation;
```

* 提交事务

```sql
commit;
```

* 回滚事务

```sql
rollback;
```

* 创建MySQL数据库用户

```sql
create user tom identified by '@pxsjdlwc'; #创建了一个用户名为tom的数据库用户，密码为@pxsjdwlc
```

* 授予权限

```sql
grant select,insert,delete,update on test.* to tom@localhost identified by '@pxsjdwlc';#给tom用户使用本地命令行方式，授予test这个库下的所有表的增删改查权限
```

## 数据库连接池

### JDBC数据库连接池的必要性

- 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　
  - **在主程序（如servlet、beans）中建立数据库连接**
  - **进行sql操作**
  - **断开数据库连接**

- 这种模式开发，存在的问题:
  - 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。
  - **对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）
  - **这种开发不能控制被创建的连接对象数**，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 

###  数据库连接池技术

- 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。
- **数据库连接池的基本思想**：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。

- **数据库连接池**负责分配、管理和释放数据库连接，它**允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个**。
- 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由**最小数据库连接数来设定**的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的**最大数据库连接数量**限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。

![image-20211102093751627](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211102093751627.png)

* 工作原理

![image-20211102093838719](F:\Users\wwwlu\AppData\Roaming\Typora\typora-user-images\image-20211102093838719.png)

- **数据库连接池技术的优点**

  **1. 资源重用**

  由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。

  **2. 更快的系统反应速度**

  数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间

  **3. 新的资源分配手段**

  对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源

  **4. 统一的连接管理，避免数据库连接泄漏**

  在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露


### 多种开源的数据库连接池

- JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：
  - **DBCP** 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。**速度相对c3p0较快**，但因自身存在BUG，Hibernate3已不再提供支持。
  - **C3P0** 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用
  - **Proxool** 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，**稳定性较c3p0差一点**
  - **BoneCP** 是一个开源组织提供的数据库连接池，速度快
  - **Druid** 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快
- DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池
- **DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。**
- 特别注意：
  - 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此**整个应用只需要一个数据源即可。**
  - 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。

### c3p0数据库连接池的两种方式

创建c3p0数据库连接池有两种方式，分别是直接获取对象并设置属性或者是通过XML文件进行创建。

```java
//方式一
//获取C3P0数据库连接池
ComboPooledDataSource cpds = new ComboPooledDataSource();
cpds.setDriverClass("com.mysql.cj.jdbc.Driver");
cpds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
cpds.setUser("root");
cpds.setPassword("13921350895lc");

//通过设置相关的参数，对数据库连接池进行管理
//设置初始时数据库连接池中的连接数
cpds.setInitialPoolSize(10);

Connection conn = cpds.getConnection();
System.out.println(conn);

//销毁cp30数据库创建的连接池
DataSources.destroy(cpds);
```

方式二：

​	创建XML文件然后读取

```xml
<?xml version="1.0" encoding="utf-8" ?>

<c3p0-config>
    <named-config name="helloc3p0">
        <!-- 提供获取连接的四个基本信息
            其中属性名称的大小写不匹配也会导致读取文件错误
        -->
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/test</property>
        <property name="user">root</property>
        <property name="password">13921350895lc</property>

        <!-- 进行数据库连接池管理的基本信息-->
        <property name="acquireIncrement">5</property> <!--当数据库连接池中的连接数不够时，c3p0一次性向数据库申请的新连接数 -->
        <property name="initialPoolSize">10</property> <!--c3p0数据库连接池中初始化时的连接数 -->
        <property name="minPoolSize">10</property> <!--c3p0数据库连接池维护的最少连接数 -->
        <property name="maxPoolSize">100</property> <!--c3p0数据库连接池维护的最大连接数 -->
        <property name="maxStatements">50</property> <!--c3p0数据库连接池最多维护的Statemnt的个数 -->
        <property name="maxStatementsPerConnection">5</property><!--每个连接中最多使用的Statement的个数 -->

    </named-config>
</c3p0-config>
```

```java
private ComboPooledDataSource cpds = new ComboPooledDataSource("helloc3p0");//数据库连接池作为属性，只需一个即可
Connection conn = cpds.getConnection();
System.out.println(conn);
```

### DBCP数据库连接池的两种方式

- DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：
  - Commons-dbcp.jar：连接池的实现
  - Commons-pool.jar：连接池实现的依赖库
- **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。
- 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。
- 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。
- 配置属性说明

| 属性                       | 默认值 | 说明                                                         |
| -------------------------- | ------ | ------------------------------------------------------------ |
| initialSize                | 0      | 连接池启动时创建的初始化连接数量                             |
| maxActive                  | 8      | 连接池中可同时连接的最大的连接数                             |
| maxIdle                    | 8      | 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 |
| minIdle                    | 0      | 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 |
| maxWait                    | 无限制 | 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 |
| poolPreparedStatements     | false  | 开启池的Statement是否prepared                                |
| maxOpenPreparedStatements  | 无限制 | 开启池的prepared 后的同时最大连接数                          |
| minEvictableIdleTimeMillis |        | 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间        |
| removeAbandonedTimeout     | 300    | 超过时间限制，回收没有用(废弃)的连接                         |
| removeAbandoned            | false  | 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 |

方式一：

```java
public void testConnection1() throws SQLException {
    //创建一个DBCP数据库连接池
    BasicDataSource basicDataSource = new BasicDataSource();

    //设置基本参数
    basicDataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
    basicDataSource.setUrl("jdbc:mysql://localhost:3306/test");
    basicDataSource.setUsername("root");
    basicDataSource.setPassword("13921350895lc");

    //其他一些属性
    basicDataSource.setInitialSize(10);//DBCO数据库连接池初始连接数
    basicDataSource.setMaxActive(100);

    Connection conn = basicDataSource.getConnection();
    System.out.println(conn);
}
```

方式二：

```java
 public void testConnection2() throws Exception {
        Properties pros = new Properties();
        //方式一
//        InputStream is = 				ClassLoader.getSystemClassLoader().getResourceAsStream("DBCP.properties");
//        pros.load(is);
        //方式二
        FileInputStream is = new FileInputStream(new File("src/DBCP.properties"));
        pros.load(is);
        DataSource dataSource = BasicDataSourceFactory.createDataSource(pros);
        Connection conn = dataSource.getConnection();
        System.out.println(conn);
    }
```

```properties
url=jdbc:mysql://localhost:3306/test
username=root
password=13921350895lc
driverClassName=com.mysql.cj.jdbc.Driver
```

### Druid(德鲁伊)数据库连接池的连接方式

Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，**可以说是目前最好的连接池之一。**

```java
/**
 * 测试druid数据库连接池的连接
 */
@Test
public void testConnection()throws Exception{
    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("druid.properties");
    Properties properties = new Properties();
    properties.load(is);

    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
    Connection conn = dataSource.getConnection();
    System.out.println(conn);

}
```

```properties
url=jdbc:mysql://localhost:3306/test
username=root
password=13921350895lc
driverClassName=com.mysql.cj.jdbc.Driver
initialSize=10
maxActive=10
```

- 详细配置参数：

| **配置**                      | **缺省** | **说明**                                                     |
| ----------------------------- | -------- | ------------------------------------------------------------ |
| name                          |          | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this) |
| url                           |          | 连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |
| username                      |          | 连接数据库的用户名                                           |
| password                      |          | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter> |
| driverClassName               |          | 根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) |
| initialSize                   | 0        | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                     | 8        | 最大连接池数量                                               |
| maxIdle                       | 8        | 已经不再使用，配置了也没效果                                 |
| minIdle                       |          | 最小连接池数量                                               |
| maxWait                       |          | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements        | false    | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxOpenPreparedStatements     | -1       | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery               |          | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |
| testOnBorrow                  | true     | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                  | false    | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle                 | false    | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| timeBetweenEvictionRunsMillis |          | 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun        |          | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis    |          |                                                              |
| connectionInitSqls            |          | 物理连接初始化的时候执行的sql                                |
| exceptionSorter               |          | 根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接 |
| filters                       |          | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall |
| proxyFilters                  |          | 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

### 总结

三种数据库连接池的连接方式大同小异，都可以通过在程序中直接设置参数连接或者写参数配置文件然后读取进行连接两种方式。其中c3p0数据库连接池读取的配置文件是XML文件，DBCP和Druid数据库连接池读取的配置是properties文件。

## Apache-DBUtils实现CRUD操作

###  Apache-DBUtils简介

- commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。

API介绍：

- org.apache.commons.dbutils.QueryRunner
- org.apache.commons.dbutils.ResultSetHandler
- 工具类：org.apache.commons.dbutils.DbUtils   

### 主要API介绍

#### DbUtils

- DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
  - **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。
  - public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。
  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接
  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 
  - public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断
  - public static void rollbackAndClose(Connection conn)throws SQLException
  - rollbackAndCloseQuietly(Connection)
  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。

#### QueryRunner类

- **该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**

- QueryRunner类提供了两个构造器：
  - 默认的构造器
  - 需要一个 javax.sql.DataSource 来作参数的构造器

- QueryRunner类的主要方法：
  - **更新**
    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。
    - ......
  - **插入**
    - public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值
    - ....
  - **批处理**
    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句
    - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句
    - .....
  - **查询**
    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。

### ResultSetHandler接口

```java
public interface ResultSetHandler<T> {
    T handle(ResultSet var1) throws SQLException;
}
```

该接口是一个泛型接口，有`MapListHandler` ` MapHandler` `BeanHandler` `ScalarHandler`等一些实现类，来封装指定类型的数据。

#### BeanHandler和BeanListHandler类

```java
/**
 * BeanHandler<T>是ResultSetHandler<T>的一个实现类，用来封装表中的一条记录
 * @throws Exception
 */
@Test
public void testQuery1()throws Exception{
    QueryRunner queryRunner = new QueryRunner();
    Connection conn = JDBCUtil.getConnection();
    String sql = "select id,name,email,birth from customers where id=?";
    BeanHandler<Customers> beanHandler = new BeanHandler<>(Customers.class);
    Customers customers = queryRunner.query(conn, sql, beanHandler, 19);//查询id为19的字段信息
    System.out.println(customers);
    JDBCUtil.closeConnection(conn,null);
}

/**
 * BeanListHandler<T>也是ResultSetHandler<T>的一个实现类，封装表中的多条记录
 * @throws Exception
 */
@Test
public void testQuery2() throws Exception{
    Connection conn = JDBCUtil.getConnection();
    QueryRunner queryRunner = new QueryRunner();
    String sql = "select id,name,email,birth from customers where id<?";
    BeanListHandler<Customers> beanListHandler = new BeanListHandler<>(Customers.class);
    List<Customers> query = queryRunner.query(conn,sql, beanListHandler, 10);
    query.forEach(System.out::println);
    JDBCUtil.closeConnection(conn,null);
}
```

#### MapHandler和MapListHandler类

```java
/**
 * MapHandler是ResultSetHandler的一个实现类，泛型指定类型为<Map<String, Object>>,以Map<String,Object>的形式返回表中的一条记录
 * @throws Exception
 */
@Test
public void testQuery3() throws Exception{
    Connection conn = JDBCUtil.getConnection();
    QueryRunner queryRunner = new QueryRunner();
    String sql = "select id,name,email,birth from customers where id=?";
    MapHandler mapHandler = new MapHandler();
    Map<String, Object> query = queryRunner.query(conn, sql, mapHandler, 5);
    System.out.println(query);
    JDBCUtil.closeConnection(conn,null);
}

@Test
public void testQuery4() throws Exception{
    Connection conn = JDBCUtil.getConnection();
    QueryRunner queryRunner = new QueryRunner();
    String sql = "select id,name,email,birth from customers where id<?";
    MapListHandler mapListHandler = new MapListHandler();
    List<Map<String, Object>> mapList = queryRunner.query(conn, sql, mapListHandler, 10);
    mapList.forEach(System.out::println);
    JDBCUtil.closeConnection(conn,null);
}
```

#### ScalarHandler类

```java
/**
 * ScalarHandler是返回表中某个属性的一个实现类，如最大值、数量等
 * @throws Exception
 */
@Test
public void testQuery5()throws Exception{
    Connection conn = JDBCUtil.getConnection();
    QueryRunner queryRunner = new QueryRunner();
    String sql = "select count(*) from customers";
    ScalarHandler scalarHandler = new ScalarHandler();
    Long count = (Long) queryRunner.query(conn, sql, scalarHandler);
    System.out.println("有"+count+"行数据");
    sql = "select max(birth) from customers";
    Date maxDate = (Date) queryRunner.query(conn,sql,scalarHandler);
    System.out.println(maxDate);
    JDBCUtil.closeConnection(conn,null);
}
```

#### 自定义实现ResultSetHandler接口

```java
public void testQuery()throws Exception{
    Connection conn = JDBCUtil.getConnection();
    QueryRunner queryRunner = new QueryRunner();
    String sql = "select id,name,email,birth from customers where id=?";
    ResultSetHandler<Customers> resultSetHandler = new ResultSetHandler<Customers>() {
        //自定义实现ResultHandler接口
        @Override
        public Customers handle(ResultSet resultSet) throws SQLException {
            if(resultSet.next()){
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String email = resultSet.getString("email");
                java.sql.Date date = resultSet.getDate("birth");
                return new Customers(id,name,email,date);
            }
            return null;
        }
    };
    Customers customer = queryRunner.query(conn, sql, resultSetHandler, 4);
    System.out.println(customer);
}
```

